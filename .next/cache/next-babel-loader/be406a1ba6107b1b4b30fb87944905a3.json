{"ast":null,"code":"import auth from '../../server/middleware/auth';\nimport connectDB from '../../server/config/db';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport { loginValidation } from '../../server/Validation';\nimport User from '../../server/models/User';\nexport default (async (req, res) => {\n  await connectDB();\n  const {\n    method\n  } = req;\n\n  if (method === 'GET') {\n    // auth(req, res);\n    //   console.log('from req', req.user);\n    const token = req.headers['x-auth-token'];\n\n    if (!token) {\n      return res.status(401).json({\n        msg: 'No token, authorization denied'\n      });\n    }\n\n    const decoded = jwt.verify(token, process.env.jwtSecret);\n    req.user = decoded.user;\n\n    try {\n      const user = await User.findById(req.user.id).select('-password');\n      res.json(user);\n    } catch (err) {\n      console.log(err.message);\n      res.status(500).send('Server error');\n    }\n  } else if (method === 'POST') {\n    const {\n      error\n    } = loginValidation(req.body);\n    if (error) return res.status(400).json({\n      msg: error.details[0].message\n    });\n    const {\n      email,\n      password\n    } = req.body;\n\n    try {\n      let user = await User.findOne({\n        email\n      });\n\n      if (!user) {\n        return res.status(400).json({\n          msg: 'Invalid Credentials'\n        });\n      }\n\n      const isMatch = await bcrypt.compare(password, user.password);\n\n      if (!isMatch) {\n        return res.status(400).json({\n          msg: 'Invalid Credentials'\n        });\n      }\n\n      const payload = {\n        user: {\n          id: user.id\n        }\n      }; // use json token\n\n      jwt.sign(payload, process.env.jwtSecret, {\n        expiresIn: 360000\n      }, (err, token) => {\n        if (err) throw err;\n        res.json({\n          token\n        });\n      });\n    } catch (err) {\n      console.error(err.message);\n      res.status(500).send('Server Error');\n    }\n  }\n}); // else if (method === 'POST') {\n//     const { error } = loginValidation(req.body);\n//     if (error) return res.status(400).json({ msg: error.details[0].message });\n//     const { email, password } = req.body;\n//     try {\n//       let user = await User.findOne({ email });\n//       if (!user) {\n//         return res.status(400).json({ msg: 'Invalid Credentials' });\n//       }\n//       const isMatch = await bcrypt.compare(password, user.password);\n//       if (!isMatch) {\n//         return res.status(400).json({ msg: 'Invalid Credentials' });\n//       }\n//       const payload = {\n//         user: {\n//           id: user.id\n//         }\n//       };\n//       // use json token\n//       jwt.sign(\n//         payload,\n//         process.env.jwtSecret,\n//         {\n//           expiresIn: 360000\n//         },\n//         (err, token) => {\n//           if (err) throw err;\n//           res.json({ token });\n//         }\n//       );\n//     } catch (err) {\n//       console.error(err.message);\n//       res.status(500).send('Server Error');\n//     }\n//   }\n// try {\n//     const { method } = req;\n//     switch (method) {\n//       case 'GET':\n//         break;\n//       default:\n//         res.setHeader('Allow', ['POST']);\n//         res.status(405).end(`Method ${method} Not Allowed`);\n//     }\n// @route   GET api/auth\n// @desc    Get logged in user\n// @access  Private\n// router.get('/', auth, async (req, res) => {\n//   try {\n//     const user = await User.findById(req.user.id).select('-password');\n//     res.json(user);\n//   } catch (err) {\n//     console.log(err.message);\n//     res.status(500).send('Server error');\n//   }\n// });\n// // @route   POST api/auth\n// // @desc    Auth user & get token\n// // @access  Public\n// router.post('/', async (req, res) => {\n//   const { error } = loginValidation(req.body);\n//   if (error) return res.status(400).json({ msg: error.details[0].message });\n//   const { email, password } = req.body;\n//   try {\n//     let user = await User.findOne({ email });\n//     if (!user) {\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\n//     }\n//     const isMatch = await bcrypt.compare(password, user.password);\n//     if (!isMatch) {\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\n//     }\n//     const payload = {\n//       user: {\n//         id: user.id\n//       }\n//     };\n//     // use json token\n//     jwt.sign(\n//       payload,\n//       process.env.jwtSecret,\n//       {\n//         expiresIn: 360000\n//       },\n//       (err, token) => {\n//         if (err) throw err;\n//         res.json({ token });\n//       }\n//     );\n//   } catch (err) {\n//     console.error(err.message);\n//     res.status(500).send('Server Error');\n//   }\n// });","map":{"version":3,"sources":["C:/Users/Eduardo Rivas/Desktop/react_Study/popcornFun/pages/api/auth.js"],"names":["auth","connectDB","bcrypt","jwt","loginValidation","User","req","res","method","token","headers","status","json","msg","decoded","verify","process","env","jwtSecret","user","findById","id","select","err","console","log","message","send","error","body","details","email","password","findOne","isMatch","compare","payload","sign","expiresIn"],"mappings":"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","sourcesContent":["import auth from '../../server/middleware/auth';\r\nimport connectDB from '../../server/config/db';\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nimport { loginValidation } from '../../server/Validation';\r\n\r\nimport User from '../../server/models/User';\r\n\r\nexport default async (req, res) => {\r\n  await connectDB();\r\n  const { method } = req;\r\n\r\n  if (method === 'GET') {\r\n    // auth(req, res);\r\n    //   console.log('from req', req.user);\r\n    const token = req.headers['x-auth-token'];\r\n\r\n    if (!token) {\r\n      return res.status(401).json({ msg: 'No token, authorization denied' });\r\n    }\r\n\r\n    const decoded = jwt.verify(token, process.env.jwtSecret);\r\n    req.user = decoded.user;\r\n\r\n    try {\r\n      const user = await User.findById(req.user.id).select('-password');\r\n      res.json(user);\r\n    } catch (err) {\r\n      console.log(err.message);\r\n      res.status(500).send('Server error');\r\n    }\r\n  } else if (method === 'POST') {\r\n    const { error } = loginValidation(req.body);\r\n\r\n    if (error) return res.status(400).json({ msg: error.details[0].message });\r\n\r\n    const { email, password } = req.body;\r\n\r\n    try {\r\n      let user = await User.findOne({ email });\r\n\r\n      if (!user) {\r\n        return res.status(400).json({ msg: 'Invalid Credentials' });\r\n      }\r\n\r\n      const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n      if (!isMatch) {\r\n        return res.status(400).json({ msg: 'Invalid Credentials' });\r\n      }\r\n\r\n      const payload = {\r\n        user: {\r\n          id: user.id\r\n        }\r\n      };\r\n\r\n      // use json token\r\n      jwt.sign(\r\n        payload,\r\n        process.env.jwtSecret,\r\n        {\r\n          expiresIn: 360000\r\n        },\r\n        (err, token) => {\r\n          if (err) throw err;\r\n          res.json({ token });\r\n        }\r\n      );\r\n    } catch (err) {\r\n      console.error(err.message);\r\n      res.status(500).send('Server Error');\r\n    }\r\n  }\r\n};\r\n\r\n// else if (method === 'POST') {\r\n//     const { error } = loginValidation(req.body);\r\n\r\n//     if (error) return res.status(400).json({ msg: error.details[0].message });\r\n\r\n//     const { email, password } = req.body;\r\n\r\n//     try {\r\n//       let user = await User.findOne({ email });\r\n\r\n//       if (!user) {\r\n//         return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//       }\r\n\r\n//       const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n//       if (!isMatch) {\r\n//         return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//       }\r\n\r\n//       const payload = {\r\n//         user: {\r\n//           id: user.id\r\n//         }\r\n//       };\r\n\r\n//       // use json token\r\n//       jwt.sign(\r\n//         payload,\r\n//         process.env.jwtSecret,\r\n//         {\r\n//           expiresIn: 360000\r\n//         },\r\n//         (err, token) => {\r\n//           if (err) throw err;\r\n//           res.json({ token });\r\n//         }\r\n//       );\r\n//     } catch (err) {\r\n//       console.error(err.message);\r\n//       res.status(500).send('Server Error');\r\n//     }\r\n//   }\r\n\r\n// try {\r\n//     const { method } = req;\r\n\r\n//     switch (method) {\r\n//       case 'GET':\r\n\r\n//         break;\r\n//       default:\r\n//         res.setHeader('Allow', ['POST']);\r\n//         res.status(405).end(`Method ${method} Not Allowed`);\r\n//     }\r\n\r\n// @route   GET api/auth\r\n// @desc    Get logged in user\r\n// @access  Private\r\n\r\n// router.get('/', auth, async (req, res) => {\r\n//   try {\r\n//     const user = await User.findById(req.user.id).select('-password');\r\n//     res.json(user);\r\n//   } catch (err) {\r\n//     console.log(err.message);\r\n//     res.status(500).send('Server error');\r\n//   }\r\n// });\r\n\r\n// // @route   POST api/auth\r\n// // @desc    Auth user & get token\r\n// // @access  Public\r\n\r\n// router.post('/', async (req, res) => {\r\n//   const { error } = loginValidation(req.body);\r\n//   if (error) return res.status(400).json({ msg: error.details[0].message });\r\n\r\n//   const { email, password } = req.body;\r\n\r\n//   try {\r\n//     let user = await User.findOne({ email });\r\n\r\n//     if (!user) {\r\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//     }\r\n\r\n//     const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n//     if (!isMatch) {\r\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//     }\r\n\r\n//     const payload = {\r\n//       user: {\r\n//         id: user.id\r\n//       }\r\n//     };\r\n\r\n//     // use json token\r\n//     jwt.sign(\r\n//       payload,\r\n//       process.env.jwtSecret,\r\n//       {\r\n//         expiresIn: 360000\r\n//       },\r\n//       (err, token) => {\r\n//         if (err) throw err;\r\n//         res.json({ token });\r\n//       }\r\n//     );\r\n//   } catch (err) {\r\n//     console.error(err.message);\r\n//     res.status(500).send('Server Error');\r\n//   }\r\n// });\r\n"]},"metadata":{},"sourceType":"module"}