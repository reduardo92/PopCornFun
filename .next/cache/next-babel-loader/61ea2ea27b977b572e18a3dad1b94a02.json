{"ast":null,"code":"import auth from '../../server/middleware/auth';\nimport connectDB from '../../server/config/db';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken';\nimport loginValidation from '../../server/Validation';\nimport User from '../../server/models/User';\nexport default (async (req, res, next) => {\n  await connectDB();\n  auth(req, res, next);\n  console.log(use);\n  console.log('from req', req.user);\n  const {\n    method\n  } = req;\n\n  try {\n    if (method === 'GET') {\n      try {\n        const user = await User.findById(req.user.id).select('-password');\n        res.json(user);\n      } catch (err) {\n        console.log(err.message);\n        res.status(500).send('Server error');\n      }\n    } else if (method === 'POST') {\n      const {\n        error\n      } = loginValidation(req.body);\n      if (error) return res.status(400).json({\n        msg: error.details[0].message\n      });\n      const {\n        email,\n        password\n      } = req.body;\n\n      try {\n        let user = await User.findOne({\n          email\n        });\n\n        if (!user) {\n          return res.status(400).json({\n            msg: 'Invalid Credentials'\n          });\n        }\n\n        const isMatch = await bcrypt.compare(password, user.password);\n\n        if (!isMatch) {\n          return res.status(400).json({\n            msg: 'Invalid Credentials'\n          });\n        }\n\n        const payload = {\n          user: {\n            id: user.id\n          }\n        }; // use json token\n\n        jwt.sign(payload, process.env.jwtSecret, {\n          expiresIn: 360000\n        }, (err, token) => {\n          if (err) throw err;\n          res.json({\n            token\n          });\n        });\n      } catch (err) {\n        console.error(err.message);\n        res.status(500).send('Server Error');\n      }\n    }\n  } catch (error) {\n    console.error(err.message);\n    res.status(500).send('Server Error');\n  }\n}); // try {\n//     const { method } = req;\n//     switch (method) {\n//       case 'GET':\n//         break;\n//       default:\n//         res.setHeader('Allow', ['POST']);\n//         res.status(405).end(`Method ${method} Not Allowed`);\n//     }\n// @route   GET api/auth\n// @desc    Get logged in user\n// @access  Private\n// router.get('/', auth, async (req, res) => {\n//   try {\n//     const user = await User.findById(req.user.id).select('-password');\n//     res.json(user);\n//   } catch (err) {\n//     console.log(err.message);\n//     res.status(500).send('Server error');\n//   }\n// });\n// // @route   POST api/auth\n// // @desc    Auth user & get token\n// // @access  Public\n// router.post('/', async (req, res) => {\n//   const { error } = loginValidation(req.body);\n//   if (error) return res.status(400).json({ msg: error.details[0].message });\n//   const { email, password } = req.body;\n//   try {\n//     let user = await User.findOne({ email });\n//     if (!user) {\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\n//     }\n//     const isMatch = await bcrypt.compare(password, user.password);\n//     if (!isMatch) {\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\n//     }\n//     const payload = {\n//       user: {\n//         id: user.id\n//       }\n//     };\n//     // use json token\n//     jwt.sign(\n//       payload,\n//       process.env.jwtSecret,\n//       {\n//         expiresIn: 360000\n//       },\n//       (err, token) => {\n//         if (err) throw err;\n//         res.json({ token });\n//       }\n//     );\n//   } catch (err) {\n//     console.error(err.message);\n//     res.status(500).send('Server Error');\n//   }\n// });","map":{"version":3,"sources":["C:/Users/Eduardo Rivas/Desktop/react_Study/popcornFun/pages/api/auth.js"],"names":["auth","connectDB","bcrypt","jwt","loginValidation","User","req","res","next","console","log","use","user","method","findById","id","select","json","err","message","status","send","error","body","msg","details","email","password","findOne","isMatch","compare","payload","sign","process","env","jwtSecret","expiresIn","token"],"mappings":"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","sourcesContent":["import auth from '../../server/middleware/auth';\r\nimport connectDB from '../../server/config/db';\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\n\r\nimport loginValidation from '../../server/Validation';\r\n\r\nimport User from '../../server/models/User';\r\n\r\nexport default async (req, res, next) => {\r\n  await connectDB();\r\n  auth(req, res, next);\r\n  console.log(use);\r\n  console.log('from req', req.user);\r\n  const { method } = req;\r\n\r\n  try {\r\n    if (method === 'GET') {\r\n      try {\r\n        const user = await User.findById(req.user.id).select('-password');\r\n        res.json(user);\r\n      } catch (err) {\r\n        console.log(err.message);\r\n        res.status(500).send('Server error');\r\n      }\r\n    } else if (method === 'POST') {\r\n      const { error } = loginValidation(req.body);\r\n\r\n      if (error) return res.status(400).json({ msg: error.details[0].message });\r\n\r\n      const { email, password } = req.body;\r\n\r\n      try {\r\n        let user = await User.findOne({ email });\r\n\r\n        if (!user) {\r\n          return res.status(400).json({ msg: 'Invalid Credentials' });\r\n        }\r\n\r\n        const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n        if (!isMatch) {\r\n          return res.status(400).json({ msg: 'Invalid Credentials' });\r\n        }\r\n\r\n        const payload = {\r\n          user: {\r\n            id: user.id\r\n          }\r\n        };\r\n\r\n        // use json token\r\n        jwt.sign(\r\n          payload,\r\n          process.env.jwtSecret,\r\n          {\r\n            expiresIn: 360000\r\n          },\r\n          (err, token) => {\r\n            if (err) throw err;\r\n            res.json({ token });\r\n          }\r\n        );\r\n      } catch (err) {\r\n        console.error(err.message);\r\n        res.status(500).send('Server Error');\r\n      }\r\n    }\r\n  } catch (error) {\r\n    console.error(err.message);\r\n    res.status(500).send('Server Error');\r\n  }\r\n};\r\n\r\n// try {\r\n//     const { method } = req;\r\n\r\n//     switch (method) {\r\n//       case 'GET':\r\n\r\n//         break;\r\n//       default:\r\n//         res.setHeader('Allow', ['POST']);\r\n//         res.status(405).end(`Method ${method} Not Allowed`);\r\n//     }\r\n\r\n// @route   GET api/auth\r\n// @desc    Get logged in user\r\n// @access  Private\r\n\r\n// router.get('/', auth, async (req, res) => {\r\n//   try {\r\n//     const user = await User.findById(req.user.id).select('-password');\r\n//     res.json(user);\r\n//   } catch (err) {\r\n//     console.log(err.message);\r\n//     res.status(500).send('Server error');\r\n//   }\r\n// });\r\n\r\n// // @route   POST api/auth\r\n// // @desc    Auth user & get token\r\n// // @access  Public\r\n\r\n// router.post('/', async (req, res) => {\r\n//   const { error } = loginValidation(req.body);\r\n//   if (error) return res.status(400).json({ msg: error.details[0].message });\r\n\r\n//   const { email, password } = req.body;\r\n\r\n//   try {\r\n//     let user = await User.findOne({ email });\r\n\r\n//     if (!user) {\r\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//     }\r\n\r\n//     const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n//     if (!isMatch) {\r\n//       return res.status(400).json({ msg: 'Invalid Credentials' });\r\n//     }\r\n\r\n//     const payload = {\r\n//       user: {\r\n//         id: user.id\r\n//       }\r\n//     };\r\n\r\n//     // use json token\r\n//     jwt.sign(\r\n//       payload,\r\n//       process.env.jwtSecret,\r\n//       {\r\n//         expiresIn: 360000\r\n//       },\r\n//       (err, token) => {\r\n//         if (err) throw err;\r\n//         res.json({ token });\r\n//       }\r\n//     );\r\n//   } catch (err) {\r\n//     console.error(err.message);\r\n//     res.status(500).send('Server Error');\r\n//   }\r\n// });\r\n"]},"metadata":{},"sourceType":"module"}