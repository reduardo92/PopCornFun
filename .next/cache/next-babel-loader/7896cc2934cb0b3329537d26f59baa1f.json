{"ast":null,"code":"// import nextConnect from 'next-connect';\n// import middleware from '../../server/middleware/database';\nimport connectDB from '../../server/config/db';\nimport bcrypt from 'bcryptjs';\nimport jwt from 'jsonwebtoken'; // Joi validation\n\nimport { registerValidation } from '../../server/Validation'; // User Model\n\nimport User from '../../server/models/User';\nexport default (async (req, res) => {\n  await connectDB();\n\n  try {\n    const {\n      method\n    } = req;\n\n    switch (method) {\n      case 'POST':\n        const {\n          error\n        } = registerValidation(req.body);\n        if (error) return res.status(400).json({\n          msg: error.details[0].message\n        });\n        const {\n          name,\n          userName,\n          email,\n          password\n        } = req.body;\n        let user = await User.findOne({\n          email\n        }); //   check is user exists\n\n        if (user) {\n          return res.status(400).json({\n            msg: 'User already exists'\n          });\n        } // create a new user\n\n\n        user = new User({\n          name,\n          userName,\n          email,\n          password\n        }); // crpt password\n\n        const salt = await bcrypt.genSalt(10);\n        user.password = await bcrypt.hash(password, salt); // save user\n\n        await user.save();\n        const payload = {\n          user: {\n            id: user.id\n          }\n        }; // use json token\n\n        jwt.sign(payload, process.env.jwtSecret, {\n          expiresIn: 360000\n        }, (err, token) => {\n          if (err) throw err;\n          res.json({\n            token\n          });\n        });\n        break;\n\n      default:\n        res.setHeader('Allow', ['POST']);\n        res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (e) {\n    res.status(500).json({\n      error: e.message || 'something went wrong'\n    });\n  }\n}); // export default async (req, res) => {\n//   await connectDB();\n//   try {\n//     const User = mongoose.models.User || mongoose.model('User', UserSchema);\n//     const {\n//       query: { name },\n//       method\n//     } = req;\n//     switch (method) {\n//       case 'POST':\n//         User.create({ name }, (error, user) => {\n//           if (error) {\n//             res.status(500).json({ error });\n//           } else {\n//             res.status(200).json(user);\n//           }\n//         });\n//         break;\n//       default:\n//         res.setHeader('Allow', ['POST']);\n//         res.status(405).end(`Method ${method} Not Allowed`);\n//     }\n//   } catch (e) {\n//     res.status(500).json({ error: e.message || 'something went wrong' });\n//   }\n// };\n// const user = nextConnect();\n// user.use(middleware);\n// console.log(user);\n// user.get(async (req, res) => {\n//   let doc = await req.db.collection('theaters').findOne();\n//   console.log(doc);\n//   res.json(doc);\n// });\n// export default user;","map":{"version":3,"sources":["C:/Users/Eduardo Rivas/Desktop/react_Study/popcornFun/pages/api/user.js"],"names":["connectDB","bcrypt","jwt","registerValidation","User","req","res","method","error","body","status","json","msg","details","message","name","userName","email","password","user","findOne","salt","genSalt","hash","save","payload","id","sign","process","env","jwtSecret","expiresIn","err","token","setHeader","end","e"],"mappings":"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","sourcesContent":["// import nextConnect from 'next-connect';\r\n// import middleware from '../../server/middleware/database';\r\nimport connectDB from '../../server/config/db';\r\nimport bcrypt from 'bcryptjs';\r\nimport jwt from 'jsonwebtoken';\r\n// Joi validation\r\nimport { registerValidation } from '../../server/Validation';\r\n// User Model\r\nimport User from '../../server/models/User';\r\n\r\nexport default async (req, res) => {\r\n  await connectDB();\r\n  try {\r\n    const { method } = req;\r\n\r\n    switch (method) {\r\n      case 'POST':\r\n        const { error } = registerValidation(req.body);\r\n        if (error)\r\n          return res.status(400).json({ msg: error.details[0].message });\r\n\r\n        const { name, userName, email, password } = req.body;\r\n\r\n        let user = await User.findOne({ email });\r\n\r\n        //   check is user exists\r\n        if (user) {\r\n          return res.status(400).json({ msg: 'User already exists' });\r\n        }\r\n        // create a new user\r\n        user = new User({\r\n          name,\r\n          userName,\r\n          email,\r\n          password\r\n        });\r\n\r\n        // crpt password\r\n        const salt = await bcrypt.genSalt(10);\r\n        user.password = await bcrypt.hash(password, salt);\r\n        // save user\r\n        await user.save();\r\n        const payload = {\r\n          user: {\r\n            id: user.id\r\n          }\r\n        };\r\n        // use json token\r\n        jwt.sign(\r\n          payload,\r\n          process.env.jwtSecret,\r\n          {\r\n            expiresIn: 360000\r\n          },\r\n          (err, token) => {\r\n            if (err) throw err;\r\n            res.json({ token });\r\n          }\r\n        );\r\n        break;\r\n      default:\r\n        res.setHeader('Allow', ['POST']);\r\n        res.status(405).end(`Method ${method} Not Allowed`);\r\n    }\r\n  } catch (e) {\r\n    res.status(500).json({ error: e.message || 'something went wrong' });\r\n  }\r\n};\r\n\r\n// export default async (req, res) => {\r\n//   await connectDB();\r\n\r\n//   try {\r\n//     const User = mongoose.models.User || mongoose.model('User', UserSchema);\r\n//     const {\r\n//       query: { name },\r\n//       method\r\n//     } = req;\r\n//     switch (method) {\r\n//       case 'POST':\r\n//         User.create({ name }, (error, user) => {\r\n//           if (error) {\r\n//             res.status(500).json({ error });\r\n//           } else {\r\n//             res.status(200).json(user);\r\n//           }\r\n//         });\r\n//         break;\r\n//       default:\r\n//         res.setHeader('Allow', ['POST']);\r\n//         res.status(405).end(`Method ${method} Not Allowed`);\r\n//     }\r\n//   } catch (e) {\r\n//     res.status(500).json({ error: e.message || 'something went wrong' });\r\n//   }\r\n// };\r\n\r\n// const user = nextConnect();\r\n\r\n// user.use(middleware);\r\n\r\n// console.log(user);\r\n\r\n// user.get(async (req, res) => {\r\n//   let doc = await req.db.collection('theaters').findOne();\r\n//   console.log(doc);\r\n//   res.json(doc);\r\n// });\r\n\r\n// export default user;\r\n"]},"metadata":{},"sourceType":"module"}