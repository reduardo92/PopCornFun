{"ast":null,"code":"// import nextConnect from 'next-connect';\n// import middleware from '../../server/middleware/database';\nimport connectDB from '../../server/config/db';\nimport User from '../../server/models/User';\nimport { registerValidation } from '../../server/Validation';\nexport default (async (req, res) => {\n  await connectDB();\n\n  try {\n    const {\n      method,\n      body: {\n        userName,\n        email,\n        password\n      }\n    } = req;\n\n    switch (method) {\n      case 'POST':\n        const {\n          error\n        } = registerValidation(req.body);\n        if (error) return res.status(400).json({\n          msg: error.details[0].message,\n          gg: 'hello'\n        });\n        let user = await User.findOne({\n          email\n        }); //   check is user exists\n\n        if (user) {\n          return res.status(400).json({\n            msg: 'User already exists'\n          });\n        } // create a new user\n\n\n        user = new User({\n          userName,\n          email,\n          password\n        }); // crpt password\n        // const salt = await bcrypt.genSalt(10);\n        // user.password = await bcrypt.hash(password, salt);\n        // save user\n\n        await user.save();\n        const payload = {\n          user: {\n            id: user.id\n          }\n        };\n        res.json(user);\n        break;\n\n      default:\n        res.setHeader('Allow', ['POST']);\n        res.status(405).end(`Method ${method} Not Allowed`);\n    }\n  } catch (e) {\n    res.status(500).json({\n      error: e.message || 'something went wrong'\n    });\n  }\n}); // export default async (req, res) => {\n//   await connectDB();\n//   try {\n//     const User = mongoose.models.User || mongoose.model('User', UserSchema);\n//     const {\n//       query: { name },\n//       method\n//     } = req;\n//     switch (method) {\n//       case 'POST':\n//         User.create({ name }, (error, user) => {\n//           if (error) {\n//             res.status(500).json({ error });\n//           } else {\n//             res.status(200).json(user);\n//           }\n//         });\n//         break;\n//       default:\n//         res.setHeader('Allow', ['POST']);\n//         res.status(405).end(`Method ${method} Not Allowed`);\n//     }\n//   } catch (e) {\n//     res.status(500).json({ error: e.message || 'something went wrong' });\n//   }\n// };\n// const user = nextConnect();\n// user.use(middleware);\n// console.log(user);\n// user.get(async (req, res) => {\n//   let doc = await req.db.collection('theaters').findOne();\n//   console.log(doc);\n//   res.json(doc);\n// });\n// export default user;","map":{"version":3,"sources":["C:/Users/Eduardo Rivas/Desktop/react_Study/popcornFun/pages/api/user.js"],"names":["connectDB","User","registerValidation","req","res","method","body","userName","email","password","error","status","json","msg","details","message","gg","user","findOne","save","payload","id","setHeader","end","e"],"mappings":"AAAA;AACA;AACA,OAAOA,SAAP,MAAsB,wBAAtB;AACA,OAAOC,IAAP,MAAiB,0BAAjB;AACA,SAASC,kBAAT,QAAmC,yBAAnC;AAEA,gBAAe,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AACjC,QAAMJ,SAAS,EAAf;;AACA,MAAI;AACF,UAAM;AACJK,MAAAA,MADI;AAEJC,MAAAA,IAAI,EAAE;AAAEC,QAAAA,QAAF;AAAYC,QAAAA,KAAZ;AAAmBC,QAAAA;AAAnB;AAFF,QAGFN,GAHJ;;AAKA,YAAQE,MAAR;AACE,WAAK,MAAL;AACE,cAAM;AAAEK,UAAAA;AAAF,YAAYR,kBAAkB,CAACC,GAAG,CAACG,IAAL,CAApC;AACA,YAAII,KAAJ,EACE,OAAON,GAAG,CACPO,MADI,CACG,GADH,EAEJC,IAFI,CAEC;AAAEC,UAAAA,GAAG,EAAEH,KAAK,CAACI,OAAN,CAAc,CAAd,EAAiBC,OAAxB;AAAiCC,UAAAA,EAAE,EAAE;AAArC,SAFD,CAAP;AAIF,YAAIC,IAAI,GAAG,MAAMhB,IAAI,CAACiB,OAAL,CAAa;AAAEV,UAAAA;AAAF,SAAb,CAAjB,CAPF,CASE;;AACA,YAAIS,IAAJ,EAAU;AACR,iBAAOb,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,YAAAA,GAAG,EAAE;AAAP,WAArB,CAAP;AACD,SAZH,CAaE;;;AACAI,QAAAA,IAAI,GAAG,IAAIhB,IAAJ,CAAS;AACdM,UAAAA,QADc;AAEdC,UAAAA,KAFc;AAGdC,UAAAA;AAHc,SAAT,CAAP,CAdF,CAmBE;AACA;AACA;AACA;;AACA,cAAMQ,IAAI,CAACE,IAAL,EAAN;AACA,cAAMC,OAAO,GAAG;AACdH,UAAAA,IAAI,EAAE;AACJI,YAAAA,EAAE,EAAEJ,IAAI,CAACI;AADL;AADQ,SAAhB;AAKAjB,QAAAA,GAAG,CAACQ,IAAJ,CAASK,IAAT;AACA;;AACF;AACEb,QAAAA,GAAG,CAACkB,SAAJ,CAAc,OAAd,EAAuB,CAAC,MAAD,CAAvB;AACAlB,QAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBY,GAAhB,CAAqB,UAASlB,MAAO,cAArC;AAlCJ;AAoCD,GA1CD,CA0CE,OAAOmB,CAAP,EAAU;AACVpB,IAAAA,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEF,MAAAA,KAAK,EAAEc,CAAC,CAACT,OAAF,IAAa;AAAtB,KAArB;AACD;AACF,CA/CD,E,CAiDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// import nextConnect from 'next-connect';\r\n// import middleware from '../../server/middleware/database';\r\nimport connectDB from '../../server/config/db';\r\nimport User from '../../server/models/User';\r\nimport { registerValidation } from '../../server/Validation';\r\n\r\nexport default async (req, res) => {\r\n  await connectDB();\r\n  try {\r\n    const {\r\n      method,\r\n      body: { userName, email, password }\r\n    } = req;\r\n\r\n    switch (method) {\r\n      case 'POST':\r\n        const { error } = registerValidation(req.body);\r\n        if (error)\r\n          return res\r\n            .status(400)\r\n            .json({ msg: error.details[0].message, gg: 'hello' });\r\n\r\n        let user = await User.findOne({ email });\r\n\r\n        //   check is user exists\r\n        if (user) {\r\n          return res.status(400).json({ msg: 'User already exists' });\r\n        }\r\n        // create a new user\r\n        user = new User({\r\n          userName,\r\n          email,\r\n          password\r\n        });\r\n        // crpt password\r\n        // const salt = await bcrypt.genSalt(10);\r\n        // user.password = await bcrypt.hash(password, salt);\r\n        // save user\r\n        await user.save();\r\n        const payload = {\r\n          user: {\r\n            id: user.id\r\n          }\r\n        };\r\n        res.json(user);\r\n        break;\r\n      default:\r\n        res.setHeader('Allow', ['POST']);\r\n        res.status(405).end(`Method ${method} Not Allowed`);\r\n    }\r\n  } catch (e) {\r\n    res.status(500).json({ error: e.message || 'something went wrong' });\r\n  }\r\n};\r\n\r\n// export default async (req, res) => {\r\n//   await connectDB();\r\n\r\n//   try {\r\n//     const User = mongoose.models.User || mongoose.model('User', UserSchema);\r\n//     const {\r\n//       query: { name },\r\n//       method\r\n//     } = req;\r\n//     switch (method) {\r\n//       case 'POST':\r\n//         User.create({ name }, (error, user) => {\r\n//           if (error) {\r\n//             res.status(500).json({ error });\r\n//           } else {\r\n//             res.status(200).json(user);\r\n//           }\r\n//         });\r\n//         break;\r\n//       default:\r\n//         res.setHeader('Allow', ['POST']);\r\n//         res.status(405).end(`Method ${method} Not Allowed`);\r\n//     }\r\n//   } catch (e) {\r\n//     res.status(500).json({ error: e.message || 'something went wrong' });\r\n//   }\r\n// };\r\n\r\n// const user = nextConnect();\r\n\r\n// user.use(middleware);\r\n\r\n// console.log(user);\r\n\r\n// user.get(async (req, res) => {\r\n//   let doc = await req.db.collection('theaters').findOne();\r\n//   console.log(doc);\r\n//   res.json(doc);\r\n// });\r\n\r\n// export default user;\r\n"]},"metadata":{},"sourceType":"module"}